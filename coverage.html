
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/marsevilspirit/m_RPC/client/client.go (58.7%)</option>
				
				<option value="file1">github.com/marsevilspirit/m_RPC/client/connection.go (36.5%)</option>
				
				<option value="file2">github.com/marsevilspirit/m_RPC/codec/codec.go (80.0%)</option>
				
				<option value="file3">github.com/marsevilspirit/m_RPC/example/helloworld/helloworld.go (0.0%)</option>
				
				<option value="file4">github.com/marsevilspirit/m_RPC/example/helloworldclient/main.go (0.0%)</option>
				
				<option value="file5">github.com/marsevilspirit/m_RPC/example/helloworldserver/main.go (0.0%)</option>
				
				<option value="file6">github.com/marsevilspirit/m_RPC/log/default_logger.go (20.0%)</option>
				
				<option value="file7">github.com/marsevilspirit/m_RPC/log/logger.go (15.4%)</option>
				
				<option value="file8">github.com/marsevilspirit/m_RPC/protocol/massage.go (73.5%)</option>
				
				<option value="file9">github.com/marsevilspirit/m_RPC/server/listener.go (0.0%)</option>
				
				<option value="file10">github.com/marsevilspirit/m_RPC/server/server.go (15.5%)</option>
				
				<option value="file11">github.com/marsevilspirit/m_RPC/server/service.go (56.2%)</option>
				
				<option value="file12">github.com/marsevilspirit/m_RPC/util/compress.go (76.5%)</option>
				
				<option value="file13">github.com/marsevilspirit/m_RPC/util/converter.go (100.0%)</option>
				
				<option value="file14">github.com/marsevilspirit/m_RPC/util/net.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "bufio"
        "context"
        "crypto/tls"
        "errors"
        "io"
        "net"
        "sync"
        "time"

        "github.com/marsevilspirit/m_RPC/log"
        "github.com/marsevilspirit/m_RPC/protocol"
        "github.com/marsevilspirit/m_RPC/share"
        "github.com/marsevilspirit/m_RPC/util"
)

var (
        ErrShutdown        = errors.New("connection is shutdown")
        ErrUnspportedCodec = errors.New("codec is unsupported")
)

const (
        ReaderBuffsize = 16 * 1024
        WriterBuffsize = 16 * 1024
)

type Call struct {
        ServicePath   string
        ServiceMethod string
        Metadata      map[string]string
        Args          interface{}
        Reply         interface{}
        Error         error
        Done          chan *Call
}

func (call *Call) done() <span class="cov8" title="1">{
        select </span>{
        case call.Done &lt;- call:<span class="cov8" title="1"></span>
                // ok
        default:<span class="cov0" title="0">
                log.Debug("rpc: discarding Call reply due to insufficient Done chan capacity")</span>
        }
}

// for context key
type seqKey struct{}

type Client struct {
        TLSConfig *tls.Config

        Conn net.Conn
        r    *bufio.Reader
        w    *bufio.Writer

        SerializeType protocol.SerializeType
        CompressType  protocol.CompressType

        mu       sync.Mutex
        seq      uint64
        pending  map[uint64]*Call
        closing  bool // closing 是用户主动关闭的
        shutdown bool // shutdown 是error发生时调用的

        ConnectTimeout time.Duration
        ReadTimeout    time.Duration
        WriteTimeout   time.Duration
}

var _ io.Closer = (*Client)(nil)

func (client *Client) Close() error <span class="cov8" title="1">{
        client.mu.Lock()

        for seq, call := range client.pending </span><span class="cov0" title="0">{
                delete(client.pending, seq)
                if call != nil </span><span class="cov0" title="0">{
                        call.Error = ErrShutdown
                        call.done()
                }</span>
        }

        <span class="cov8" title="1">if client.closing || client.shutdown </span><span class="cov0" title="0">{
                client.mu.Unlock()
                return ErrShutdown
        }</span>

        <span class="cov8" title="1">client.closing = true
        client.mu.Unlock()
        return client.Conn.Close()</span>
}

func (client *Client) Call(ctx context.Context, servicePath, serviceMethod string, args interface{}, reply interface{}) error <span class="cov8" title="1">{
        seq := new(uint64)
        ctx = context.WithValue(ctx, seqKey{}, seq)
        Done := client.Go(ctx, servicePath, serviceMethod, args, reply, make(chan *Call, 1)).Done

        var err error
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                client.mu.Lock()
                call := client.pending[*seq]
                delete(client.pending, *seq)
                client.mu.Unlock()
                if call != nil </span><span class="cov0" title="0">{
                        call.Error = ctx.Err()
                        call.done()
                }</span>

                <span class="cov0" title="0">return ctx.Err()</span>
        case call := &lt;-Done:<span class="cov8" title="1">
                err = call.Error</span>
        }

        <span class="cov8" title="1">return err</span>
}

func (client *Client) Go(ctx context.Context, servicePath, serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call <span class="cov8" title="1">{
        call := &amp;Call{
                ServicePath:   servicePath,
                ServiceMethod: serviceMethod,
                Args:          args,
                Reply:         reply,
                Done:          done,
        }

        if call.Done == nil </span><span class="cov0" title="0">{
                call.Done = make(chan *Call, 10)
        }</span> else<span class="cov8" title="1"> if cap(call.Done) == 0 </span><span class="cov0" title="0">{
                log.Panic("rpc: done channel is unbuffered")
        }</span>

        <span class="cov8" title="1">call.Done = done
        client.send(ctx, call)
        return call</span>
}

func (client *Client) send(ctx context.Context, call *Call) <span class="cov8" title="1">{
        client.mu.Lock()
        if client.shutdown || client.closing </span><span class="cov0" title="0">{
                call.Error = ErrShutdown
                client.mu.Unlock()
                call.done()
                return
        }</span>

        <span class="cov8" title="1">codec := share.Codecs[client.SerializeType]
        if codec == nil </span><span class="cov0" title="0">{
                call.Error = ErrUnspportedCodec
                client.mu.Unlock()
                call.done()
                return
        }</span>

        <span class="cov8" title="1">if client.pending == nil </span><span class="cov8" title="1">{
                client.pending = make(map[uint64]*Call)
        }</span>

        <span class="cov8" title="1">seq := client.seq
        client.seq++
        client.pending[seq] = call
        client.mu.Unlock()

        if cseq, ok := ctx.Value(seqKey{}).(*uint64); ok </span><span class="cov8" title="1">{
                *cseq = seq
        }</span>

        <span class="cov8" title="1">req := protocol.NewMessage()
        req.SetMessageType(protocol.Request)
        req.SetSeq(seq)
        req.SetSerializeType(client.SerializeType)
        req.Metadata[protocol.ServicePath] = call.ServicePath
        req.Metadata[protocol.ServiceMethod] = call.ServiceMethod

        data, err := codec.Encode(call.Args)
        if err != nil </span><span class="cov0" title="0">{
                call.Error = err
                call.done()
                return
        }</span>

        <span class="cov8" title="1">if len(data) &gt; 1024 &amp;&amp; client.CompressType == protocol.Gzip </span><span class="cov0" title="0">{
                data, err = util.Zip(data)
                if err != nil </span><span class="cov0" title="0">{
                        call.Error = err
                        call.done()
                        return
                }</span>

                <span class="cov0" title="0">req.SetCompressType(client.CompressType)</span>
        }

        <span class="cov8" title="1">req.Payload = data

        _, err = req.WriteTo(client.w)
        if err == nil </span><span class="cov8" title="1">{
                err = client.w.Flush()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                client.mu.Lock()
                call = client.pending[seq]
                delete(client.pending, seq)
                client.mu.Unlock()
                if call != nil </span><span class="cov0" title="0">{
                        call.Error = err
                        call.done()
                }</span>
        }
}

func (client *Client) receive() <span class="cov8" title="1">{
        var err error
        var res *protocol.Message

        for err == nil </span><span class="cov8" title="1">{
                res, err = protocol.Read(client.r)

                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">seq := res.Seq()
                client.mu.Lock()
                call := client.pending[seq]
                delete(client.pending, seq)
                client.mu.Unlock()

                switch </span>{
                case call == nil:<span class="cov0" title="0"></span>

                case res.MessageStatusType() == protocol.Error:<span class="cov8" title="1">
                        call.Error = errors.New(res.Metadata[protocol.ServiceError])
                        call.done()</span>
                default:<span class="cov8" title="1">
                        data := res.Payload
                        if res.CompressType() == protocol.Gzip </span><span class="cov0" title="0">{
                                data, err = util.Unzip(data)
                                if err != nil </span><span class="cov0" title="0">{
                                        call.Error = errors.New("unzip payload: " + err.Error())
                                }</span>
                        }

                        <span class="cov8" title="1">codec := share.Codecs[res.SerializeType()]
                        if codec == nil </span><span class="cov0" title="0">{
                                call.Error = ErrUnspportedCodec
                        }</span> else<span class="cov8" title="1"> {
                                err = codec.Decode(data, call.Reply)
                                if err != nil </span><span class="cov0" title="0">{
                                        call.Error = err
                                }</span>
                        }

                        <span class="cov8" title="1">call.done()</span>
                }
        }

        <span class="cov8" title="1">client.mu.Lock()
        client.shutdown = true
        closing := client.closing
        if err == io.EOF </span><span class="cov0" title="0">{
                if closing </span><span class="cov0" title="0">{
                        err = ErrShutdown
                }</span> else<span class="cov0" title="0"> {
                        err = io.ErrUnexpectedEOF
                }</span>
        }

        <span class="cov8" title="1">for _, call := range client.pending </span><span class="cov0" title="0">{
                call.Error = err
                call.done()
        }</span>

        <span class="cov8" title="1">client.mu.Unlock()
        if err != io.EOF &amp;&amp; !closing </span><span class="cov0" title="0">{
                log.Error("mrpc: client protocol error:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "bufio"
        "crypto/tls"
        "errors"
        "io"
        "net"
        "net/http"
        "time"

        "github.com/marsevilspirit/m_RPC/log"
        "github.com/marsevilspirit/m_RPC/share"
)

func (c *Client) Connect(network, address string, opts ...interface{}) error <span class="cov8" title="1">{
        var conn net.Conn
        var err error

        switch network </span>{
        case "http":<span class="cov0" title="0">
                conn, err = newDirectHTTPConn(c, network, address)</span>
        default:<span class="cov8" title="1">
                conn, err = newDirectTCPConn(c, network, address)</span>
        }

        <span class="cov8" title="1">if err == nil &amp;&amp; conn != nil </span><span class="cov8" title="1">{
                if c.ReadTimeout != 0 </span><span class="cov0" title="0">{
                        conn.SetReadDeadline(time.Now().Add(c.ReadTimeout))
                }</span>
                <span class="cov8" title="1">if c.WriteTimeout != 0 </span><span class="cov0" title="0">{
                        conn.SetWriteDeadline(time.Now().Add(c.WriteTimeout))
                }</span>

                <span class="cov8" title="1">c.Conn = conn
                c.r = bufio.NewReaderSize(conn, ReaderBuffsize)
                c.w = bufio.NewWriterSize(conn, WriterBuffsize)

                go c.receive()</span>
        }

        <span class="cov8" title="1">return err</span>
}

func newDirectTCPConn(c *Client, network, address string, opts ...interface{}) (net.Conn, error) <span class="cov8" title="1">{
        var conn net.Conn
        var tlsConn *tls.Conn
        var err error

        if c != nil &amp;&amp; c.TLSConfig != nil </span><span class="cov0" title="0">{
                dialer := &amp;net.Dialer{
                        Timeout: c.ConnectTimeout,
                }
                tlsConn, err = tls.DialWithDialer(dialer, network, address, c.TLSConfig)
                conn = net.Conn(tlsConn)
        }</span> else<span class="cov8" title="1"> {
                conn, err = net.DialTimeout(network, address, c.ConnectTimeout)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to dial server: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return conn, nil</span>
}

var connected = "200 Connected to mrpc"

func newDirectHTTPConn(c *Client, network, address string, opts ...interface{}) (net.Conn, error) <span class="cov0" title="0">{
        var path string

        if len(opts) &gt; 0 </span><span class="cov0" title="0">{
                path = opts[0].(string)
        }</span> else<span class="cov0" title="0"> {
                path = share.DefaultRPCPath
        }</span>

        <span class="cov0" title="0">network = "tcp"

        var conn net.Conn
        var tlsConn *tls.Conn
        var err error

        if c != nil &amp;&amp; c.TLSConfig != nil </span><span class="cov0" title="0">{
                dialer := &amp;net.Dialer{
                        Timeout: c.ConnectTimeout,
                }
                tlsConn, err = tls.DialWithDialer(dialer, network, address, c.TLSConfig)

                conn = net.Conn(tlsConn)
        }</span> else<span class="cov0" title="0"> {
                conn, err = net.DialTimeout(network, address, c.ConnectTimeout)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to dial server: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">io.WriteString(conn, "CONNECT "+path+" HTTP/1.0\n\n")

        resp, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request{Method: "CONNECT"})
        if err == nil &amp;&amp; resp.Status == connected </span><span class="cov0" title="0">{
                return conn, nil
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                log.Errorf("unexpected HTTP response: %v", err)
                err = errors.New("unexpected HTTP response: " + resp.Status)
        }</span>
        <span class="cov0" title="0">conn.Close()
        return nil, &amp;net.OpError{
                Op:   "dial-http",
                Net:  network + " " + address,
                Addr: nil,
                Err:  err,
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package codec

import (
        "encoding/json"
        "fmt"

        pb "github.com/gogo/protobuf/proto"
        "github.com/vmihailenco/msgpack/v5"
)

type Codec interface {
        Encode(i interface{}) ([]byte, error)
        Decode(data []byte, i interface{}) error
}

type ByteCodec struct{}

func (c ByteCodec) Encode(i interface{}) ([]byte, error) <span class="cov8" title="1">{
        if data, ok := i.([]byte); ok </span><span class="cov8" title="1">{
                return data, nil
        }</span>

        //%T获取i的类型
        <span class="cov8" title="1">return nil, fmt.Errorf("%T is not a []byte", i)</span>
}

func (c ByteCodec) Decode(data []byte, i interface{}) error <span class="cov0" title="0">{
        i = &amp;data
        return nil
}</span>

type JSONCodec struct{}

func (c JSONCodec) Encode(i interface{}) ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(i)
}</span>

func (c JSONCodec) Decode(data []byte, i interface{}) error <span class="cov8" title="1">{
        return json.Unmarshal(data, i)
}</span>

type ProtobufCodec struct{}

func (c ProtobufCodec) Encode(i interface{}) ([]byte, error) <span class="cov8" title="1">{
        if m, ok := i.(pb.Marshaler); ok </span><span class="cov8" title="1">{
                return m.Marshal()
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("%T is not a pb.Marshaler", i)</span>
}

func (c ProtobufCodec) Decode(data []byte, i interface{}) error <span class="cov8" title="1">{
        if m, ok := i.(pb.Unmarshaler); ok </span><span class="cov8" title="1">{
                return m.Unmarshal(data)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("%T is not a proto.Unmarshaler", i)</span>
}

type MsgpackCodec struct{}

func (c MsgpackCodec) Encode(i interface{}) ([]byte, error) <span class="cov8" title="1">{
        return msgpack.Marshal(i)
}</span>

func (c MsgpackCodec) Decode(data []byte, i interface{}) error <span class="cov8" title="1">{
        return msgpack.Unmarshal(data, i)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package helloworld

import "context"

type HelloWorld struct{}

type HelloWorldArgs struct {
        First string
}

type HelloWorldReply struct {
        Last string
}

func (h *HelloWorld) Helloworld(ctx context.Context, args *HelloWorldArgs, reply *HelloWorldReply) error <span class="cov0" title="0">{
        reply.Last = args.First + " world!"
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/marsevilspirit/m_RPC/client"
        "github.com/marsevilspirit/m_RPC/example/helloworld"
        "github.com/marsevilspirit/m_RPC/log"
        "github.com/marsevilspirit/m_RPC/protocol"
)

func main() <span class="cov0" title="0">{
        client := client.Client{
                SerializeType: protocol.JSON,
                CompressType:  protocol.Gzip,
        }

        err := client.Connect("tcp", "127.0.0.1:50000")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect: %v", err)
        }</span>

        <span class="cov0" title="0">args := &amp;helloworld.HelloWorldArgs{
                First: "hello",
        }

        reply := &amp;helloworld.HelloWorldReply{}

        err = client.Call(context.Background(), "HelloWorld", "Helloworld", args, reply)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to call: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("reply:", reply.Last)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/marsevilspirit/m_RPC/example/helloworld"
        "github.com/marsevilspirit/m_RPC/server"
)

func main() <span class="cov0" title="0">{
        server := server.Server{}
        server.Register(new(helloworld.HelloWorld))
        server.Serve("tcp", "127.0.0.1:50000")
        defer server.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package log

import (
        "fmt"
        "log"
        "os"

        "github.com/fatih/color"
)

type defaultLogger struct {
        *log.Logger
}

func (l *defaultLogger) Debug(v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header("DEBUG", fmt.Sprint(v...)))
}</span>
func (l *defaultLogger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header("DEBUG", fmt.Sprintf(format, v...)))
}</span>

func (l *defaultLogger) Info(v ...interface{}) <span class="cov8" title="1">{
        l.Output(calldepth, header(color.GreenString("INFO "), fmt.Sprint(v...)))
}</span>
func (l *defaultLogger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.GreenString("INFO "), fmt.Sprintf(format, v...)))
}</span>

func (l *defaultLogger) Warn(v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.YellowString("WARN "), fmt.Sprint(v...)))
}</span>
func (l *defaultLogger) Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.YellowString("WARN "), fmt.Sprintf(format, v...)))
}</span>

func (l *defaultLogger) Error(v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.RedString("ERROR"), fmt.Sprint(v...)))
}</span>
func (l *defaultLogger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        l.Output(calldepth, header(color.RedString("ERROR"), fmt.Sprintf(format, v...)))
}</span>

func (l *defaultLogger) Fatal(v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.MagentaString("FATAL"), fmt.Sprint(v...)))
        os.Exit(1)
}</span>
func (l *defaultLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Output(calldepth, header(color.MagentaString("FATAL"), fmt.Sprintf(format, v...)))
        os.Exit(1)
}</span>

func (l *defaultLogger) Panic(v ...interface{}) <span class="cov0" title="0">{
        l.Logger.Panic(v...)
}</span>
func (l *defaultLogger) Panicf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Logger.Panicf(format, v...)
}</span>

func header(lvl, msg string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", lvl, msg)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package log

import (
        "log"
        "os"
)

const (
        calldepth = 3
)

var l Logger = &amp; defaultLogger{log.New(os.Stderr, "", log.LstdFlags|log.Lshortfile)}

type Logger interface {
        Debug(v ...interface{})
        Debugf(format string, v ...interface{})

        Info(v ...interface{})
        Infof(format string, v ...interface{})

        Warn(v ...interface{})
        Warnf(format string, v ...interface{})

        Error(v ...interface{})
        Errorf(format string, v ...interface{})

        Fatal(v ...interface{})
        Fatalf(format string, v ...interface{})

        Panic(v ...interface{})
        Panicf(format string, v ...interface{})
}

func SetLogger(logger Logger) <span class="cov0" title="0">{
        l = logger
}</span>

func Debug(v ...interface{}) <span class="cov0" title="0">{
        l.Debug(v...)
}</span>
func Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Debugf(format, v...)
}</span>

func Info(v ...interface{}) <span class="cov8" title="1">{
        l.Info(v...)
}</span>
func Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Infof(format, v...)
}</span>

func Warn(v ...interface{}) <span class="cov0" title="0">{
        l.Warn(v...)
}</span>
func Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Warnf(format, v...)
}</span>

func Error(v ...interface{}) <span class="cov0" title="0">{
        l.Error(v...)
}</span>
func Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        l.Errorf(format, v...)
}</span>

func Fatal(v ...interface{}) <span class="cov0" title="0">{
        l.Fatal(v...)
}</span>
func Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Fatalf(format, v...)
}</span>

func Panic(v ...interface{}) <span class="cov0" title="0">{
        l.Panic(v...)
}</span>
func Panicf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Panicf(format, v...)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package protocol

import (
        "bytes"
        "encoding/binary"
        "errors"
        "io"

        "github.com/marsevilspirit/m_RPC/util"
)

const (
        magicNumber byte = 0x42
)

var (
        lineSeparator = []byte("\r\n")
)

var (
        ErrMetaKVMissing = errors.New("wrong metadata lines. some keys or values are missing")
)

const (
        ServicePath   = "__mrpc_path__"
        ServiceMethod = "__mrpc_method__"
        ServiceError  = "__mrpc_error__"
)

type MessageType byte

// MessageType只有两种
// Request 和 Response
const (
        Request MessageType = iota
        Response
)

type MessageStatusType byte

const (
        Normal MessageStatusType = iota
        Error
)

type CompressType byte

const (
        None CompressType = iota
        Gzip
        // TODO: etc...
)

type SerializeType byte

const (
        SerializeNone SerializeType = iota
        JSON
        ProtoBuffer
        MsgPack
)

type Message struct {
        *Header
        Metadata map[string]string // map[string]string[]???
        Payload  []byte
}

func NewMessage() *Message <span class="cov8" title="1">{
        header := Header([12]byte{})
        header[0] = magicNumber

        return &amp;Message{
                Header:   &amp;header,
                Metadata: make(map[string]string),
        }
}</span>

// Header:
// +---------------------------------------------+
// |magicNumber|version|h[2]|SerializeType|Seq...|
// +---------------------------------------------+
//
// h[2]的第8位是MessageType, 第7位是IsHeartbeat, 第6位是IsOneway
// 第5-3位是CompressType
type Header [12]byte

func (h Header) CheckMagicNumber() bool <span class="cov8" title="1">{
        return h[0] == magicNumber
}</span>

func (h *Header) Version() byte <span class="cov8" title="1">{
        return h[1]
}</span>

func (h *Header) SetVersion(v byte) <span class="cov8" title="1">{
        h[1] = v
}</span>

// 0x80在二进制中是1000 0000
// 用 &amp; 提取第三字节的最高位
func (h Header) MessageType() MessageType <span class="cov0" title="0">{
        return MessageType(h[2] &amp; 0x80)
}</span>

func (h *Header) SetMessageType(mt MessageType) <span class="cov8" title="1">{
        h[2] = h[2] | (byte(mt) &lt;&lt; 7)
}</span>

func (h Header) IsHeartbeat() bool <span class="cov8" title="1">{
        return h[2]&amp;0x40 == 0x40
}</span>

func (h *Header) SetHeartbeat(hb bool) <span class="cov8" title="1">{
        if hb </span><span class="cov8" title="1">{
                h[2] = h[2] | 0x40
        }</span> else<span class="cov8" title="1"> {
                h[2] = h[2] &amp;^ 0x40
        }</span>
}

func (h Header) IsOneway() bool <span class="cov8" title="1">{
        return h[2]&amp;0x20 == 0x20
}</span>

func (h *Header) SetOneway(oneway bool) <span class="cov8" title="1">{
        if oneway </span><span class="cov8" title="1">{
                h[2] = h[2] | 0x20
        }</span> else<span class="cov8" title="1"> {
                h[2] = h[2] &amp;^ 0x20
        }</span>
}

func (h Header) CompressType() CompressType <span class="cov8" title="1">{
        return CompressType((h[2] &amp; 0x1C) &gt;&gt; 2)
}</span>

func (h *Header) SetCompressType(ct CompressType) <span class="cov8" title="1">{
        h[2] = h[2] | ((byte(ct) &lt;&lt; 2) &amp; 0x1C)
}</span>

func (h Header) MessageStatusType() MessageStatusType <span class="cov0" title="0">{
        return MessageStatusType(h[2] &amp; 0x03)
}</span>

func (h *Header) SetMessageStatusType(mt MessageStatusType) <span class="cov8" title="1">{
        h[2] = h[2] | (byte(mt) &amp; 0x03)
}</span>

// 0xF0 是 1111 0000
func (h Header) SerializeType() SerializeType <span class="cov8" title="1">{
        return SerializeType((h[3] &amp; 0xF0) &gt;&gt; 4)
}</span>

func (h *Header) SetSerializeType(st SerializeType) <span class="cov8" title="1">{
        h[3] = h[3] | (byte(st) &lt;&lt; 4)
}</span>

func (h Header) Seq() uint64 <span class="cov8" title="1">{
        return binary.BigEndian.Uint64(h[4:])
}</span>

func (h *Header) SetSeq(seq uint64) <span class="cov8" title="1">{
        binary.BigEndian.PutUint64(h[4:], seq)
}</span>

func (m Message) Clone() *Message <span class="cov0" title="0">{
        header := *m.Header
        c := &amp;Message{
                Header:   &amp;header,
                Metadata: make(map[string]string),
        }
        return c
}</span>

func (m Message) Encode() []byte <span class="cov0" title="0">{
        meta := encodeMetadata(m.Metadata)

        // 4 指明长度
        l := 12 + (4 + len(meta)) + (4 + len(m.Payload))

        data := make([]byte, l)
        copy(data, m.Header[:])
        binary.BigEndian.PutUint32(data[12:16], uint32(len(meta)))
        copy(data[12:], meta)
        binary.BigEndian.PutUint32(data[16+len(meta):], uint32(len(m.Payload)))
        copy(data[20+len(meta):], m.Payload)

        return data
}</span>

func (m Message) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        var bytes int64

        n, err := w.Write(m.Header[:])
        if err != nil </span><span class="cov0" title="0">{
                return bytes, err
        }</span>

        <span class="cov8" title="1">bytes = int64(n)

        meta := encodeMetadata(m.Metadata)
        err = binary.Write(w, binary.BigEndian, uint32(len(meta)))
        if err != nil </span><span class="cov0" title="0">{
                return bytes, err
        }</span>

        <span class="cov8" title="1">bytes += int64(binary.Size(uint32(len(meta))))

        n, err = w.Write(meta)
        if err != nil </span><span class="cov0" title="0">{
                return bytes, err
        }</span>

        <span class="cov8" title="1">bytes += int64(n)

        err = binary.Write(w, binary.BigEndian, uint32(len(m.Payload)))
        if err != nil </span><span class="cov0" title="0">{
                return bytes, err
        }</span>

        <span class="cov8" title="1">bytes += int64(binary.Size(uint32(len(m.Payload))))

        n, err = w.Write(m.Payload)
        if err != nil </span><span class="cov0" title="0">{
                return bytes, err
        }</span>

        <span class="cov8" title="1">bytes += int64(n)

        return bytes, err</span>
}

func encodeMetadata(m map[string]string) []byte <span class="cov8" title="1">{
        var buf bytes.Buffer
        for k, v := range m </span><span class="cov8" title="1">{
                buf.WriteString(k)
                buf.Write(lineSeparator)
                buf.WriteString(v)
                buf.Write(lineSeparator)
        }</span>

        <span class="cov8" title="1">return buf.Bytes()</span>
}

func decodeMetadata(lenData []byte, r io.Reader) (map[string]string, error) <span class="cov8" title="1">{
        _, err := io.ReadFull(r, lenData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">l := binary.BigEndian.Uint32(lenData)
        m := make(map[string]string)
        if l == 0 </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov8" title="1">data := make([]byte, l)
        _, err = io.ReadFull(r, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">meta := bytes.Split(data, lineSeparator)
        if len(meta)%2 != 1 </span><span class="cov0" title="0">{
                return nil, ErrMetaKVMissing
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(meta)-1; i = i + 2 </span><span class="cov8" title="1">{
                m[util.SliceByteToString(meta[i])] = util.SliceByteToString(meta[i+1])
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}

func Read(r io.Reader) (*Message, error) <span class="cov8" title="1">{
        msg := NewMessage()
        _, err := io.ReadFull(r, msg.Header[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">lenData := make([]byte, 4)
        msg.Metadata, err = decodeMetadata(lenData, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = io.ReadFull(r, lenData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">l := binary.BigEndian.Uint32(lenData)

        msg.Payload = make([]byte, l)

        _, err = io.ReadFull(r, msg.Payload)

        return msg, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "net"

        reuseport "github.com/kavu/go_reuseport"
)

// validIP4 函数用于检测一个地址是否为有效的 IPv4 地址
func validIP4(address string) bool <span class="cov0" title="0">{
        ip := net.ParseIP(address)
        return ip != nil &amp;&amp; ip.To4() != nil
}</span>

func makeListener(network, address string) (ln net.Listener, err error) <span class="cov0" title="0">{
        switch network </span>{
        case "reuseport":<span class="cov0" title="0">
                if validIP4(address) </span><span class="cov0" title="0">{
                        network = "tcp4"
                }</span> else<span class="cov0" title="0"> {
                        network = "tcp6"
                }</span>

                <span class="cov0" title="0">ln, err = reuseport.NewReusablePortListener(network, address)</span>

        default:<span class="cov0" title="0">
                ln, err = net.Listen(network, address)</span>
        }

        <span class="cov0" title="0">return ln, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "bufio"
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "reflect"
        "runtime"
        "sync"
        "time"

        "github.com/marsevilspirit/m_RPC/log"
        "github.com/marsevilspirit/m_RPC/protocol"
        "github.com/marsevilspirit/m_RPC/share"
)

var ErrServerClosed = errors.New("http: Server closed")

const (
        ReaderBufferSize = 1024
        WriterBufferSize = 1024
)

type contextKey struct {
        name string
}

func (k *contextKey) String() string <span class="cov0" title="0">{
        return "mrpc context value " + k.name
}</span>

var (
        RemoteConnContextKey = &amp;contextKey{"remote-conn"}
)

type Server struct {
        ln           net.Listener
        ReadTimeout  time.Duration
        WriteTimeout time.Duration

        serviceMapMu sync.RWMutex
        serviceMap   map[string]*service

        mu         sync.Mutex
        activeConn map[net.Conn]struct{}
        done       chan struct{}

        inShutdown int32
        onShutdown []func()
}

func (s *Server) Address() net.Addr <span class="cov0" title="0">{
        if s.ln == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.ln.Addr()</span>
}

func (s *Server) getDone() &lt;-chan struct{} <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.done == nil </span><span class="cov0" title="0">{
                s.done = make(chan struct{})
        }</span>

        <span class="cov0" title="0">return s.done</span>
}

func (s *Server) Serve(network, address string) (err error) <span class="cov0" title="0">{
        var ln net.Listener

        ln, err = makeListener(network, address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Info("serving on ", ln.Addr().String())

        if network == "http" </span><span class="cov0" title="0">{
                s.serveByHTTP(ln, "")
                return nil
        }</span>

        <span class="cov0" title="0">return s.serveListener(ln)</span>
}

func (s *Server) serveListener(ln net.Listener) error <span class="cov0" title="0">{
        s.ln = ln

        var tempDelay time.Duration

        s.mu.Lock()
        if s.activeConn == nil </span><span class="cov0" title="0">{
                s.activeConn = make(map[net.Conn]struct{})
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()

        for </span><span class="cov0" title="0">{
                conn, e := ln.Accept()
                if e != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.getDone():<span class="cov0" title="0">
                                return ErrServerClosed</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">if ne, ok := e.(interface{ Temporary() bool }); ok &amp;&amp; ne.Temporary() </span><span class="cov0" title="0">{
                                if tempDelay == 0 </span><span class="cov0" title="0">{
                                        tempDelay = 5 * time.Millisecond
                                }</span> else<span class="cov0" title="0"> {
                                        tempDelay *= 2
                                }</span>

                                <span class="cov0" title="0">if max := 1 * time.Second; tempDelay &gt; max </span><span class="cov0" title="0">{
                                        tempDelay = max
                                }</span>

                                <span class="cov0" title="0">log.Errorf("mrpc: Accept error: %v; retrying in %v", e, tempDelay)
                                time.Sleep(tempDelay)
                                continue</span>
                        }
                        <span class="cov0" title="0">return e</span>
                }
                <span class="cov0" title="0">tempDelay = 0

                if tc, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                        tc.SetKeepAlive(true)
                        tc.SetKeepAlivePeriod(3 * time.Minute)
                }</span>

                <span class="cov0" title="0">s.mu.Lock()
                s.activeConn[conn] = struct{}{}
                s.mu.Unlock()

                go s.serveConn(conn)</span>
        }
}

func (s *Server) serveByHTTP(ln net.Listener, rpcPath string) <span class="cov0" title="0">{
        s.ln = ln

        if rpcPath == "" </span><span class="cov0" title="0">{
                rpcPath = share.DefaultRPCPath
        }</span>
        <span class="cov0" title="0">http.Handle(rpcPath, s)
        srv := &amp;http.Server{Handler: nil}

        s.mu.Lock()
        if s.activeConn == nil </span><span class="cov0" title="0">{
                s.activeConn = make(map[net.Conn]struct{})
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()

        srv.Serve(ln)</span>
}

func (s *Server) serveConn(conn net.Conn) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        const size = 64 &lt;&lt; 10
                        buf := make([]byte, size)
                        buf = buf[:runtime.Stack(buf, false)]
                        log.Errorf("serving %s panic error: %s, stack:\n %s", conn.RemoteAddr(), err, buf)
                }</span>

                <span class="cov0" title="0">s.mu.Lock()
                delete(s.activeConn, conn)
                s.mu.Unlock()
                conn.Close()</span>
        }()

        <span class="cov0" title="0">if tlsConn, ok := conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                if d := s.ReadTimeout; d != 0 </span><span class="cov0" title="0">{
                        conn.SetReadDeadline(time.Now().Add(d))
                }</span>
                <span class="cov0" title="0">if d := s.WriteTimeout; d != 0 </span><span class="cov0" title="0">{
                        conn.SetWriteDeadline(time.Now().Add(d))
                }</span>
                <span class="cov0" title="0">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("mrpc: TLS handshake error from %s: %v", conn.RemoteAddr(), err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.WithValue(context.Background(), RemoteConnContextKey, conn)
        r := bufio.NewReaderSize(conn, ReaderBufferSize)
        w := bufio.NewWriterSize(conn, WriterBufferSize)

        for </span><span class="cov0" title="0">{
                now := time.Now()

                if s.ReadTimeout != 0 </span><span class="cov0" title="0">{
                        conn.SetReadDeadline(now.Add(s.ReadTimeout))
                }</span>

                <span class="cov0" title="0">req, err := s.readRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("mrpc: failed to read request: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if s.WriteTimeout != 0 </span><span class="cov0" title="0">{
                        conn.SetWriteDeadline(now.Add(s.WriteTimeout))
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        res, err := s.handleRequest(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("mrpc: failed to handle request: %v", err)
                        }</span>

                        <span class="cov0" title="0">res.WriteTo(w)
                        w.Flush()</span>
                }()
        }
}

func (s *Server) readRequest(ctx context.Context, r io.Reader) (req *protocol.Message, err error) <span class="cov0" title="0">{
        req, err = protocol.Read(r)
        return req, err
}</span>

func (s *Server) handleRequest(ctx context.Context, req *protocol.Message) (res *protocol.Message, err error) <span class="cov8" title="1">{
        res = req.Clone()
        res.SetMessageType(protocol.Response)

        serviceName := req.Metadata[protocol.ServicePath]
        methodName := req.Metadata[protocol.ServiceMethod]
        s.serviceMapMu.RLock()
        service := s.serviceMap[serviceName]
        s.serviceMapMu.RUnlock()
        if service == nil </span><span class="cov0" title="0">{
                err = errors.New("mrpc: can't find service " + serviceName)
                return handleError(res, err)
        }</span>
        <span class="cov8" title="1">mtype := service.method[methodName]
        if mtype == nil </span><span class="cov0" title="0">{
                err = errors.New("mrpc: can't find method " + methodName)
                return handleError(res, err)
        }</span>

        <span class="cov8" title="1">var argv, replyv reflect.Value

        argIsValue := false
        if mtype.ArgType.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                argv = reflect.New(mtype.ArgType.Elem())
        }</span> else<span class="cov0" title="0"> {
                argv = reflect.New(mtype.ArgType)
                argIsValue = true
        }</span>

        <span class="cov8" title="1">if argIsValue </span><span class="cov0" title="0">{
                argv = argv.Elem()
        }</span>

        <span class="cov8" title="1">codec := share.Codecs[req.SerializeType()]
        if codec == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("can not find codec for %d", req.SerializeType())
                return handleError(res, err)
        }</span>

        <span class="cov8" title="1">err = codec.Decode(req.Payload, argv.Interface())
        if err != nil </span><span class="cov0" title="0">{
                return handleError(res, err)
        }</span>

        <span class="cov8" title="1">replyv = reflect.New(mtype.ReplyType.Elem())

        err = service.call(ctx, mtype, argv, replyv)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(res, err)
        }</span>

        <span class="cov8" title="1">data, err := codec.Encode(replyv.Interface())
        if err != nil </span><span class="cov0" title="0">{
                return handleError(res, err)
        }</span>

        <span class="cov8" title="1">res.Payload = data
        return res, nil</span>
}

func handleError(res *protocol.Message, err error) (*protocol.Message, error) <span class="cov0" title="0">{
        res.SetMessageStatusType(protocol.Error)
        res.Metadata[protocol.ServiceError] = err.Error()
        return res, err
}</span>

var connected = "200 Connected to mrpc"

func (s *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if req.Method != "CONNECT" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.WriteHeader(http.StatusMethodNotAllowed)
                io.WriteString(w, "405 must CONNECT\n")
                return
        }</span>
        <span class="cov0" title="0">conn, _, err := w.(http.Hijacker).Hijack()
        if err != nil </span><span class="cov0" title="0">{
                log.Info("rpc hijacking", req.RemoteAddr, ": ", err.Error())
                return
        }</span>
        <span class="cov0" title="0">io.WriteString(conn, "HTTP/1.0 "+connected+"\n\n")

        s.mu.Lock()
        s.activeConn[conn] = struct{}{}
        s.mu.Unlock()

        s.serveConn(conn)</span>
}

func (s *Server) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.closeDoneLocked()
        err := s.ln.Close()

        for c := range s.activeConn </span><span class="cov0" title="0">{
                c.Close()
                delete(s.activeConn, c)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// 优雅关闭连接
func (s *Server) RegisterOnShutdown(f func()) <span class="cov0" title="0">{
        s.mu.Lock()
        s.onShutdown = append(s.onShutdown, f)
        s.mu.Unlock()
}</span>

func (s *Server) closeDoneLocked() <span class="cov0" title="0">{
        ch := s.getDoneLocked()
        select </span>{
        case &lt;-ch:<span class="cov0" title="0"></span>
                // 已经关闭，不用再次关闭
        default:<span class="cov0" title="0">
                close(ch)</span>
        }
}

func (s *Server) getDoneLocked() chan struct{} <span class="cov0" title="0">{
        if s.done == nil </span><span class="cov0" title="0">{
                s.done = make(chan struct{})
        }</span>

        <span class="cov0" title="0">return s.done</span>
}

func (s *Server) HandleHTTP(rpcPath, debugPath string) <span class="cov0" title="0">{
        http.Handle(rpcPath, s)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "context"
        "errors"
        "go/ast"
        "reflect"
        "sync"

        "github.com/marsevilspirit/m_RPC/log"
)

var typeOfError = reflect.TypeOf((*error)(nil)).Elem()

var typeOfContext = reflect.TypeOf((*context.Context)(nil)).Elem()

type methodType struct {
        sync.Mutex
        method    reflect.Method
        ArgType   reflect.Type
        ReplyType reflect.Type
        numCalls  uint
}

type service struct {
        name   string
        rcvr   reflect.Value          // receiver of methods for the service
        typ    reflect.Type           // type of the receiver
        method map[string]*methodType // 注册方法
}

func isExportedOrBuiltinType(t reflect.Type) bool <span class="cov8" title="1">{
        // 解引用指针类型，直到得到非指针类型
        for t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>

        // t.PkgPath() == "" 的判断是用来检查类型是否为内建类型或未命名类型
        <span class="cov8" title="1">return ast.IsExported(t.Name()) || t.PkgPath() == ""</span>
}

func (s *Server) Register(rcvr interface{}) error <span class="cov8" title="1">{
        return s.register(rcvr, "", false)
}</span>

func (s *Server) RegisterWithName(name string, rcvr interface{}) error <span class="cov8" title="1">{
        return s.register(rcvr, name, true)
}</span>

func (s *Server) register(rcvr interface{}, name string, useName bool) error <span class="cov8" title="1">{
        s.serviceMapMu.Lock()
        defer s.serviceMapMu.Unlock()

        if s.serviceMap == nil </span><span class="cov8" title="1">{
                s.serviceMap = make(map[string]*service)
        }</span>

        <span class="cov8" title="1">service := new(service)
        service.typ = reflect.TypeOf(rcvr)
        service.rcvr = reflect.ValueOf(rcvr)
        sname := reflect.Indirect(service.rcvr).Type().Name()

        if useName </span><span class="cov8" title="1">{
                sname = name
        }</span>

        <span class="cov8" title="1">if sname == "" </span><span class="cov0" title="0">{
                errorStr := "mrpc.register: no service name for type " + service.typ.String()
                log.Error(errorStr)
                return errors.New(errorStr)
        }</span>

        <span class="cov8" title="1">if !useName &amp;&amp; !ast.IsExported(sname) </span><span class="cov0" title="0">{
                errorStr := "mrpc.register: type " + sname + " is not exported"
                log.Error(errorStr)
                return errors.New(errorStr)
        }</span>

        <span class="cov8" title="1">service.name = sname

        service.method = suitableMethods(service.typ, true)

        if len(service.method) == 0 </span><span class="cov0" title="0">{
                errorStr := ""

                method := suitableMethods(reflect.PointerTo(service.typ), false)
                if len(method) != 0 </span><span class="cov0" title="0">{
                        errorStr = "mrpc.register: type " + sname + " has no exportedmethods of suitable type (hint: pass a pointer to value of that type)"
                }</span> else<span class="cov0" title="0"> {
                        errorStr = "mrpc.register: type " + sname + " has no exportedmethods of suitable type"
                }</span>
                <span class="cov0" title="0">log.Error(errorStr)
                return errors.New(errorStr)</span>
        }
        <span class="cov8" title="1">s.serviceMap[service.name] = service
        return nil</span>
}

func suitableMethods(typ reflect.Type, reportErr bool) map[string]*methodType <span class="cov8" title="1">{
        methods := make(map[string]*methodType)

        for m := 0; m &lt; typ.NumMethod(); m++ </span><span class="cov8" title="1">{
                method := typ.Method(m)
                mtype := method.Type
                mname := method.Name

                if method.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // receiver, context.Context, *args, *reply
                <span class="cov8" title="1">if mtype.NumIn() != 4 </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "has wrong number of ins:", mtype.NumIn())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">ctxType := mtype.In(1)
                if !ctxType.Implements(typeOfContext) </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "has wrong number of ins:", mtype.NumIn())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">argType := mtype.In(2)
                if !isExportedOrBuiltinType(argType) </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info(mname, "argument type not exported:", argType)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // must be a pointer
                <span class="cov8" title="1">replyType := mtype.In(3)
                if replyType.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "reply type not a pointer")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if !isExportedOrBuiltinType(replyType) </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "reply type not exported:", replyType)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if mtype.NumOut() != 1 </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "has wrong number of outs: ", mtype.NumOut())
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if returnType := mtype.Out(0); returnType != typeOfError </span><span class="cov0" title="0">{
                        if reportErr </span><span class="cov0" title="0">{
                                log.Info("method", mname, "returns", returnType.String(), "not error")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">methods[mname] = &amp;methodType{
                        method:    method,
                        ArgType:   argType,
                        ReplyType: replyType,
                }</span>
        }

        <span class="cov8" title="1">return methods</span>
}

func (s *service) call(ctx context.Context, mtype *methodType, argv, replyv reflect.Value) error <span class="cov8" title="1">{
        f := mtype.method.Func

        returnValues := f.Call([]reflect.Value{s.rcvr, reflect.ValueOf(ctx), argv, replyv})

        if errInter := returnValues[0].Interface(); errInter != nil </span><span class="cov8" title="1">{
                return errInter.(error)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package util

import (
        "bytes"
        "compress/gzip"
        "io"
)

func Unzip(data []byte) ([]byte, error) <span class="cov8" title="1">{
        gr, err := gzip.NewReader(bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer gr.Close()

        uzdata, err := io.ReadAll(gr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return uzdata, err</span>
}

func Zip(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer

        w := gzip.NewWriter(&amp;buf)
        _, err := w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package util

// 日后可以使用unsafe pointer来避免内存拷贝

func SliceByteToString(b []byte) string <span class="cov8" title="1">{
        return string(b)
}</span>

func StringToSliceByte(s string) []byte <span class="cov8" title="1">{
        return []byte(s)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package util

import (
        "net"
)

// GetFreePort 获取一个系统分配的空闲端口
func GetFreePort() (port int, err error) <span class="cov8" title="1">{
        listener, err := net.Listen("tcp", "127.0.0.1:0")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer listener.Close()

        // 从监听器地址中提取出分配的端口
        addr := listener.Addr().(*net.TCPAddr)
        return addr.Port, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
